import { LoginForm2 } from '../../examples/login/version_2'


The backend team wants to make sure you at least make sure the values don't have spaces in them; the passwords must be eight or
more characters and are busy thinking of more interesting requirements for usernames and passwords.
And they want to display errors if the field has been touched.

Treating fields as a single value doesn't cut it any more, so you add a branch for each field with custom handling,
and render the input fields around those branches. Luckily you can pass a branch into a component and work on its
local context, and it will still feed back to the parent.

```javascript

export function makeField(title, type, validator) {
  return new Leaf({
      title,
      value: '',
      type,
      touched: false
    },
    {

      actions: {
        update(leaf, value) {
          leaf.do.setValue(value)
          leaf.do.setTouched(true)
        },
        isValid(leaf) {
          return !leaf.do.errors()
        },
        isEmpty(leaf) {
          return !leaf.value.value
        },
        errors(leaf) {
          if (leaf.do.isEmpty()) {
            return 'must have a value'
          }
          return validator(leaf.value.value)
        }
      }
    })
}

```

this field leaf will serve as a "branch" -- a sub-leaf that will communicate with and provide the value for a field in the root leaf:

```jsx
    const login = new Leaf({
        status: 'entering',
        response: null
      },
      {
        branches: {
          username: makeField('User Name', 'text', (value) => {
            if (/[\s]+/.test(value)) {
              return 'username cannot have spaces'
            }
          }),
          password: makeField('Password', 'password', (value) => {
            if (/[\s]+/.test(value)) {
              return 'password cannot have spaces'
            }
            if (value.length < 8) {
              return 'password must be 8 or more characters';
            }
          })
        },
        actions: {
          isReady(leaf) {
            if (!(leaf.value.password.value && leaf.value.username.value)) return false;
            if (!leaf.branch('username').do.isValid() || !leaf.branch('password').do.isValid()) {
              return false;
            }
            return true;
          },
          reset(leaf) {
            leaf.next({
              status: 'entering',
              response: null,
              password: {value: '', touched: false},
              username: {value: '', touched: false}
            })
          }
        }
      }
    )
```

We can even pull values from the sub-leaf actions, as is shown in isReady.

The login form now uses a sub-component for the leaf fields:

```jsx
export const LoginForm2 = () => {
  const [state, setState] = useState(false)
  const [login, setLogin] = useState(null)
  useEffect(() => {
    const login = new Leaf(//...
    );

    const sub = login.subscribe({
      next (value){
        const state = { ...value, isReady: login.do.isReady() }
        setState(state)
      },
    })

    setLogin(login)

    return () => {
      sub.unsubscribe()
    }
  }, [])

  if (!(state && login)) {
    return ''
  }

  return <>
    <div className='login-box'>
      <div className='flex-item'>
        <LeafInput branch={login.branch('username')} />
        <LeafInput branch={login.branch('password')} />
      </div>
      <div className='flex-item'>
        <button type='submit' disabled={!login.do.isReady()}>Log In</button>
        <button type='reset' onClick={login.do.reset}>Reset</button>
      </div>
    </div>
    <pre>
       {JSON.stringify(state, true, 3)}
     </pre>
  </>
}
```
The LeafInput component is designed to focus exclusively on a field branch:

```jsx
export const LeafInput = ({branch}) => {

  function makeState(value = null) {
    if (!value) value = branch.value;
    return {...value, isValid: branch.do.isValid(), errors : branch.do.errors()};
  }
  const [state, setState] = useState(makeState());
  useEffect(() => {
    const sub = branch.subscribe((value) => {
      const state = makeState(value);
      setState(state);
    });

    return () => {
      sub.unsubscribe();
    }
  }, []);
  if (!(state && branch)) return '';
  return  <>
    <h2>{state.title}</h2>
    <input type={state.type} value={state.value}
      onChange={(event) => branch.do.update(event.target.value)} />
    {state.touched && branch.do.errors() ? <div className="error">{branch.do.errors()}</div> : '' }
  </>
}
```

even though it only calls update methods on the child branch, the effects percolate up to the parent.

<LoginForm2 />
